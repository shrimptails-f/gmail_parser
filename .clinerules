# Cline 使用ガイド

## 重要
回答は日本語で行ってください。
これを読んでいるあなたをこれからRooと呼称することにします。

ユーザーはRooよりプログラミングが得意ですが、時短のためにRooにコーディングを依頼しています。
2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考えます。
私は GitHub から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方は私が実装するよりも速いでしょう。テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書きます。

反面、現在のコンテキストに応じた処理は苦手です。コンテキストが不明瞭な時は、ユーザーに確認します。

## 作業開始準備
`git status` で現在の git のコンテキストを確認します。
もし指示された内容と無関係な変更が多い場合、現在の変更からユーザーに別のタスクとして開始するように提案してください。

無視するように言われた場合は、そのまま続行します。

# プロジェクト概要
このプロジェクトはコマンドライン実行を前提としたGoアプリケーションです。
Webサーバーではなく、CLIツールとして動作します。

# ディレクトリ構成
- cmd/: コマンドラインアプリケーションのエントリーポイント
  - gmail_auth/: Gmail認証機能のCLIツール
- internal/: 内部パッケージ
  - auth/: 認証関連の機能
- tools/: ユーティリティツール
  - config/: 設定管理
  - logger/: ロギング
  - mysql/: MySQL接続管理
- test/: テスト関連
  - fixture/: テストフィクスチャ
  - mock/: モックオブジェクト

# テスト駆動開発 (TDD) の基本
## 基本概念
テスト駆動開発(TDD)は以下のサイクルで進める開発手法です：
1. **Red**: まず失敗するテストを書く
2. **Green**: テストが通るように最小限の実装をする
3. **Refactor**: コードをリファクタリングして改善する

## 重要な考え方
- **テストは仕様である**: テストコードは実装の仕様を表現したもの
- **Assert-Act-Arrange の順序で考える**:
  1. まず期待する結果(アサーション)を定義
  2. 次に操作(テスト対象の処理)を定義
  3. 最後に準備(テスト環境のセットアップ)を定義
- **テスト名は「状況→操作→結果」の形式で記述**:
  例: 「有効なトークンの場合にユーザー情報を取得すると成功すること」

## 実装方針
### 基本原則
- クリーンアーキテクチャに従って実装する
- 最初に型と、それを処理する関数のインターフェースを考える
- コードのコメントとして、そのファイルがどういう仕様かを可能な限り明記する
- **実装例に影響されて不要な関数を作らない** - 必要な機能のみを実装する

### エラー処理
- エラーは適切に伝播させる
- エラーメッセージは具体的かつ明確に
- ドメインエラーとシステムエラーを区別する
- エラーラッピングを活用して文脈を追加する(fmt.Errorf("context: %w", err))

### 実装の選択基準

1. 関数を選ぶ場合
   - 単純な操作のみ
   - 内部状態が不要
   - 依存が少ない
   - テストが容易

2. 構造体を選ぶ場合
   - 内部状態の管理が必要
   - 設定やリソースの保持が必要
   - メソッド間で状態を共有
   - ライフサイクル管理が必要

3. インターフェースを選ぶ場合
   - 外部依存の抽象化
   - テスト時のモック化が必要
   - 実装の詳細を隠蔽したい
   - 差し替え可能性を確保したい

### 一般的なルール

1. 依存性の注入
   - 外部依存はコンストラクタで注入
   - テスト時にモックに置き換え可能に
   - グローバルな状態を避ける

2. インターフェースの設計
   - 必要最小限のメソッドを定義
   - 実装の詳細を含めない
   - プラットフォーム固有の型を避ける

3. テスト容易性
   - モックの実装を簡潔に
   - エッジケースのテストを含める
   - テストヘルパーを適切に分離

4. コードの分割
   - 単一責任の原則に従う
   - 適切な粒度でモジュール化
   - 循環参照を避ける

## プロジェクト固有のパターン

### 依存性注入
```go
container := dig.New()
ProvideCommonDependencies(container, conn)
ProvideAuthDependencies(container)
// コンテナからの依存性の取得
container.Invoke(func(authUseCase *authusecase.AuthUseCase) {
    // authUseCaseを使用
})
```

# テスト実装方針
クリーンアーキテクチャに基づいたテスト実装の方針について説明します。各層ごとに適切なテスト戦略を採用することで、コードの品質を確保します。

## 各層のテスト方針

### 1. ドメイン層のテスト
- ドメインモデルの振る舞いをテスト
- 外部依存がないため、モックは不要
- ビジネスルールが正しく実装されているかを検証

### 2. アプリケーション層のテスト
- ユースケースの振る舞いをテスト
- 依存するリポジトリをモック化
- 正常系と異常系の両方をテスト
- エラーハンドリングが適切に行われているかを検証

### 3. インフラストラクチャ層のテスト
- リポジトリの実装をテスト
- 実際のデータベースを使用した統合テスト
- テストデータを使用して、データの取得・保存が正しく行われるかを検証
- `//go:build integration` タグを使用して通常のテストと分離

### 4. コマンドライン層のテスト
- CLIコマンドの振る舞いをテスト
- 依存するユースケースをモック化
- 標準入出力やコマンドライン引数の処理をテスト
- 終了コードが正しいかを検証

## モックの使用方針

### 1. モックの作成
- `github.com/stretchr/testify/mock` パッケージを使用
- インターフェースに対してモックを作成
- 各メソッドの振る舞いを `.On()` と `.Return()` で定義
- `.Once()` を使用して呼び出し回数を制限

### 2. モックの検証
- テスト終了時に `AssertExpectations(t)` で期待通りに呼び出されたか検証
- 特定のパラメータでの呼び出しを検証する場合は具体的な値を指定
- 任意のパラメータを許容する場合は `mock.Anything` を使用

### 3. モックの注意点
- ロガーなどの副作用のみのインターフェースは、モックの期待を設定しない場合もある
- モックの期待が多すぎると、実装の詳細に依存したテストになりがち
- テストの意図を明確にするため、必要最小限のモックの期待を設定する

## テストケースの設計

### 1. 正常系テスト
- 期待通りの入力に対して、正しい結果が返ることを検証
- 境界値（最小値、最大値など）も考慮
- 複数の正常パターンを網羅

### 2. 異常系テスト
- 無効な入力に対して、適切なエラーが返ることを検証
- 存在しないリソース、権限エラー、バリデーションエラーなど
- エラーメッセージやステータスコードが適切かを検証

### 3. エッジケース
- 空の入力、ゼロ値、非常に大きな値など
- 特殊文字、国際化文字など
- タイムアウト、ネットワークエラーなど

## テスト実行方法

### 1. 単体テスト
```bash
go test ./internal/auth/application/...  # アプリケーション層のテスト
go test ./cmd/gmail_auth/...             # コマンドライン層のテスト
```

### 2. 統合テスト
```bash
go test -tags=integration ./internal/auth/infrastructure/... # インフラストラクチャ層の統合テスト
```

### 3. 全テスト
```bash
go test ./internal/auth/... # 認証機能の全テスト
go test ./...               # プロジェクト全体のテスト
```

### 4. カバレッジ
```bash
go test -cover ./internal/auth/... # カバレッジ情報を表示
go test -coverprofile=coverage.out ./internal/auth/... # カバレッジ情報をファイルに出力
go tool cover -html=coverage.out # カバレッジレポートをブラウザで表示
```

## 重要な注意事項
- **実装例はあくまで参考** - 実装例に影響されて不要な関数やメソッドを作成しない
- **必要最小限の実装** - 要求された機能のみを実装し、余計な機能は追加しない
- **現在のアーキテクチャを維持** - 既存の設計パターンを尊重し、一貫性を保つ
- **TDDサイクルを守る** - テストファーストで開発を進める
